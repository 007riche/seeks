// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_dht_5flayer1_2eproto__INCLUDED
#define PROTOBUF_dht_5flayer1_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace dht {
namespace l1 {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_dht_5flayer1_2eproto();
void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class header;
class net_address;
class dht_key;
class vnodeid;
class l1_query;
class l1_response;

// ===================================================================

class header : public ::google::protobuf::Message {
 public:
  header();
  virtual ~header();
  
  header(const header& from);
  
  inline header& operator=(const header& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const header& default_instance();
  void Swap(header* other);
  
  // implements Message ----------------------------------------------
  
  header* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 layer_id = 1;
  inline bool has_layer_id() const;
  inline void clear_layer_id();
  inline ::google::protobuf::uint32 layer_id() const;
  inline void set_layer_id(::google::protobuf::uint32 value);
  
  // optional uint32 fct_id = 2;
  inline bool has_fct_id() const;
  inline void clear_fct_id();
  inline ::google::protobuf::uint32 fct_id() const;
  inline void set_fct_id(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 layer_id_;
  ::google::protobuf::uint32 fct_id_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static header* default_instance_;
};
// -------------------------------------------------------------------

class net_address : public ::google::protobuf::Message {
 public:
  net_address();
  virtual ~net_address();
  
  net_address(const net_address& from);
  
  inline net_address& operator=(const net_address& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const net_address& default_instance();
  void Swap(net_address* other);
  
  // implements Message ----------------------------------------------
  
  net_address* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ip_addr = 1;
  inline bool has_ip_addr() const;
  inline void clear_ip_addr();
  inline ::google::protobuf::uint32 ip_addr() const;
  inline void set_ip_addr(::google::protobuf::uint32 value);
  
  // required bytes net_port = 2;
  inline bool has_net_port() const;
  inline void clear_net_port();
  inline const ::std::string& net_port() const;
  inline void set_net_port(const ::std::string& value);
  inline void set_net_port(const char* value);
  inline void set_net_port(const void* value, size_t size);
  inline ::std::string* mutable_net_port();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 ip_addr_;
  ::std::string* net_port_;
  static const ::std::string _default_net_port_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static net_address* default_instance_;
};
// -------------------------------------------------------------------

class dht_key : public ::google::protobuf::Message {
 public:
  dht_key();
  virtual ~dht_key();
  
  dht_key(const dht_key& from);
  
  inline dht_key& operator=(const dht_key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const dht_key& default_instance();
  void Swap(dht_key* other);
  
  // implements Message ----------------------------------------------
  
  dht_key* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static dht_key* default_instance_;
};
// -------------------------------------------------------------------

class vnodeid : public ::google::protobuf::Message {
 public:
  vnodeid();
  virtual ~vnodeid();
  
  vnodeid(const vnodeid& from);
  
  inline vnodeid& operator=(const vnodeid& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const vnodeid& default_instance();
  void Swap(vnodeid* other);
  
  // implements Message ----------------------------------------------
  
  vnodeid* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dht.l1.dht_key key = 1;
  inline bool has_key() const;
  inline void clear_key();
  inline const ::dht::l1::dht_key& key() const;
  inline ::dht::l1::dht_key* mutable_key();
  
  // required .dht.l1.net_address addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  inline const ::dht::l1::net_address& addr() const;
  inline ::dht::l1::net_address* mutable_addr();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::dht::l1::dht_key* key_;
  ::dht::l1::net_address* addr_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static vnodeid* default_instance_;
};
// -------------------------------------------------------------------

class l1_query : public ::google::protobuf::Message {
 public:
  l1_query();
  virtual ~l1_query();
  
  l1_query(const l1_query& from);
  
  inline l1_query& operator=(const l1_query& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const l1_query& default_instance();
  void Swap(l1_query* other);
  
  // implements Message ----------------------------------------------
  
  l1_query* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dht.l1.header head = 1;
  inline bool has_head() const;
  inline void clear_head();
  inline const ::dht::l1::header& head() const;
  inline ::dht::l1::header* mutable_head();
  
  // required .dht.l1.vnodeid recipient = 2;
  inline bool has_recipient() const;
  inline void clear_recipient();
  inline const ::dht::l1::vnodeid& recipient() const;
  inline ::dht::l1::vnodeid* mutable_recipient();
  
  // required .dht.l1.vnodeid sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  inline const ::dht::l1::vnodeid& sender() const;
  inline ::dht::l1::vnodeid* mutable_sender();
  
  // optional .dht.l1.dht_key lookedup_key = 4;
  inline bool has_lookedup_key() const;
  inline void clear_lookedup_key();
  inline const ::dht::l1::dht_key& lookedup_key() const;
  inline ::dht::l1::dht_key* mutable_lookedup_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::dht::l1::header* head_;
  ::dht::l1::vnodeid* recipient_;
  ::dht::l1::vnodeid* sender_;
  ::dht::l1::dht_key* lookedup_key_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static l1_query* default_instance_;
};
// -------------------------------------------------------------------

class l1_response : public ::google::protobuf::Message {
 public:
  l1_response();
  virtual ~l1_response();
  
  l1_response(const l1_response& from);
  
  inline l1_response& operator=(const l1_response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const l1_response& default_instance();
  void Swap(l1_response* other);
  
  // implements Message ----------------------------------------------
  
  l1_response* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .dht.l1.header head = 1;
  inline bool has_head() const;
  inline void clear_head();
  inline const ::dht::l1::header& head() const;
  inline ::dht::l1::header* mutable_head();
  
  // optional uint32 error_status = 2;
  inline bool has_error_status() const;
  inline void clear_error_status();
  inline ::google::protobuf::uint32 error_status() const;
  inline void set_error_status(::google::protobuf::uint32 value);
  
  // optional .dht.l1.vnodeid found_vnode = 3;
  inline bool has_found_vnode() const;
  inline void clear_found_vnode();
  inline const ::dht::l1::vnodeid& found_vnode() const;
  inline ::dht::l1::vnodeid* mutable_found_vnode();
  
  // optional .dht.l1.vnodeid found_vnode_succ = 4;
  inline bool has_found_vnode_succ() const;
  inline void clear_found_vnode_succ();
  inline const ::dht::l1::vnodeid& found_vnode_succ() const;
  inline ::dht::l1::vnodeid* mutable_found_vnode_succ();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::dht::l1::header* head_;
  ::google::protobuf::uint32 error_status_;
  ::dht::l1::vnodeid* found_vnode_;
  ::dht::l1::vnodeid* found_vnode_succ_;
  friend void protobuf_BuildDesc_dht_5flayer1_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static l1_response* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// header

// required uint32 layer_id = 1;
inline bool header::has_layer_id() const {
  return _has_bit(0);
}
inline void header::clear_layer_id() {
  layer_id_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 header::layer_id() const {
  return layer_id_;
}
inline void header::set_layer_id(::google::protobuf::uint32 value) {
  _set_bit(0);
  layer_id_ = value;
}

// optional uint32 fct_id = 2;
inline bool header::has_fct_id() const {
  return _has_bit(1);
}
inline void header::clear_fct_id() {
  fct_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 header::fct_id() const {
  return fct_id_;
}
inline void header::set_fct_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  fct_id_ = value;
}

// -------------------------------------------------------------------

// net_address

// required uint32 ip_addr = 1;
inline bool net_address::has_ip_addr() const {
  return _has_bit(0);
}
inline void net_address::clear_ip_addr() {
  ip_addr_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 net_address::ip_addr() const {
  return ip_addr_;
}
inline void net_address::set_ip_addr(::google::protobuf::uint32 value) {
  _set_bit(0);
  ip_addr_ = value;
}

// required bytes net_port = 2;
inline bool net_address::has_net_port() const {
  return _has_bit(1);
}
inline void net_address::clear_net_port() {
  if (net_port_ != &_default_net_port_) {
    net_port_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& net_address::net_port() const {
  return *net_port_;
}
inline void net_address::set_net_port(const ::std::string& value) {
  _set_bit(1);
  if (net_port_ == &_default_net_port_) {
    net_port_ = new ::std::string;
  }
  net_port_->assign(value);
}
inline void net_address::set_net_port(const char* value) {
  _set_bit(1);
  if (net_port_ == &_default_net_port_) {
    net_port_ = new ::std::string;
  }
  net_port_->assign(value);
}
inline void net_address::set_net_port(const void* value, size_t size) {
  _set_bit(1);
  if (net_port_ == &_default_net_port_) {
    net_port_ = new ::std::string;
  }
  net_port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* net_address::mutable_net_port() {
  _set_bit(1);
  if (net_port_ == &_default_net_port_) {
    net_port_ = new ::std::string;
  }
  return net_port_;
}

// -------------------------------------------------------------------

// dht_key

// required bytes key = 1;
inline bool dht_key::has_key() const {
  return _has_bit(0);
}
inline void dht_key::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& dht_key::key() const {
  return *key_;
}
inline void dht_key::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void dht_key::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void dht_key::set_key(const void* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* dht_key::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// -------------------------------------------------------------------

// vnodeid

// required .dht.l1.dht_key key = 1;
inline bool vnodeid::has_key() const {
  return _has_bit(0);
}
inline void vnodeid::clear_key() {
  if (key_ != NULL) key_->::dht::l1::dht_key::Clear();
  _clear_bit(0);
}
inline const ::dht::l1::dht_key& vnodeid::key() const {
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::dht::l1::dht_key* vnodeid::mutable_key() {
  _set_bit(0);
  if (key_ == NULL) key_ = new ::dht::l1::dht_key;
  return key_;
}

// required .dht.l1.net_address addr = 2;
inline bool vnodeid::has_addr() const {
  return _has_bit(1);
}
inline void vnodeid::clear_addr() {
  if (addr_ != NULL) addr_->::dht::l1::net_address::Clear();
  _clear_bit(1);
}
inline const ::dht::l1::net_address& vnodeid::addr() const {
  return addr_ != NULL ? *addr_ : *default_instance_->addr_;
}
inline ::dht::l1::net_address* vnodeid::mutable_addr() {
  _set_bit(1);
  if (addr_ == NULL) addr_ = new ::dht::l1::net_address;
  return addr_;
}

// -------------------------------------------------------------------

// l1_query

// required .dht.l1.header head = 1;
inline bool l1_query::has_head() const {
  return _has_bit(0);
}
inline void l1_query::clear_head() {
  if (head_ != NULL) head_->::dht::l1::header::Clear();
  _clear_bit(0);
}
inline const ::dht::l1::header& l1_query::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::dht::l1::header* l1_query::mutable_head() {
  _set_bit(0);
  if (head_ == NULL) head_ = new ::dht::l1::header;
  return head_;
}

// required .dht.l1.vnodeid recipient = 2;
inline bool l1_query::has_recipient() const {
  return _has_bit(1);
}
inline void l1_query::clear_recipient() {
  if (recipient_ != NULL) recipient_->::dht::l1::vnodeid::Clear();
  _clear_bit(1);
}
inline const ::dht::l1::vnodeid& l1_query::recipient() const {
  return recipient_ != NULL ? *recipient_ : *default_instance_->recipient_;
}
inline ::dht::l1::vnodeid* l1_query::mutable_recipient() {
  _set_bit(1);
  if (recipient_ == NULL) recipient_ = new ::dht::l1::vnodeid;
  return recipient_;
}

// required .dht.l1.vnodeid sender = 3;
inline bool l1_query::has_sender() const {
  return _has_bit(2);
}
inline void l1_query::clear_sender() {
  if (sender_ != NULL) sender_->::dht::l1::vnodeid::Clear();
  _clear_bit(2);
}
inline const ::dht::l1::vnodeid& l1_query::sender() const {
  return sender_ != NULL ? *sender_ : *default_instance_->sender_;
}
inline ::dht::l1::vnodeid* l1_query::mutable_sender() {
  _set_bit(2);
  if (sender_ == NULL) sender_ = new ::dht::l1::vnodeid;
  return sender_;
}

// optional .dht.l1.dht_key lookedup_key = 4;
inline bool l1_query::has_lookedup_key() const {
  return _has_bit(3);
}
inline void l1_query::clear_lookedup_key() {
  if (lookedup_key_ != NULL) lookedup_key_->::dht::l1::dht_key::Clear();
  _clear_bit(3);
}
inline const ::dht::l1::dht_key& l1_query::lookedup_key() const {
  return lookedup_key_ != NULL ? *lookedup_key_ : *default_instance_->lookedup_key_;
}
inline ::dht::l1::dht_key* l1_query::mutable_lookedup_key() {
  _set_bit(3);
  if (lookedup_key_ == NULL) lookedup_key_ = new ::dht::l1::dht_key;
  return lookedup_key_;
}

// -------------------------------------------------------------------

// l1_response

// required .dht.l1.header head = 1;
inline bool l1_response::has_head() const {
  return _has_bit(0);
}
inline void l1_response::clear_head() {
  if (head_ != NULL) head_->::dht::l1::header::Clear();
  _clear_bit(0);
}
inline const ::dht::l1::header& l1_response::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::dht::l1::header* l1_response::mutable_head() {
  _set_bit(0);
  if (head_ == NULL) head_ = new ::dht::l1::header;
  return head_;
}

// optional uint32 error_status = 2;
inline bool l1_response::has_error_status() const {
  return _has_bit(1);
}
inline void l1_response::clear_error_status() {
  error_status_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 l1_response::error_status() const {
  return error_status_;
}
inline void l1_response::set_error_status(::google::protobuf::uint32 value) {
  _set_bit(1);
  error_status_ = value;
}

// optional .dht.l1.vnodeid found_vnode = 3;
inline bool l1_response::has_found_vnode() const {
  return _has_bit(2);
}
inline void l1_response::clear_found_vnode() {
  if (found_vnode_ != NULL) found_vnode_->::dht::l1::vnodeid::Clear();
  _clear_bit(2);
}
inline const ::dht::l1::vnodeid& l1_response::found_vnode() const {
  return found_vnode_ != NULL ? *found_vnode_ : *default_instance_->found_vnode_;
}
inline ::dht::l1::vnodeid* l1_response::mutable_found_vnode() {
  _set_bit(2);
  if (found_vnode_ == NULL) found_vnode_ = new ::dht::l1::vnodeid;
  return found_vnode_;
}

// optional .dht.l1.vnodeid found_vnode_succ = 4;
inline bool l1_response::has_found_vnode_succ() const {
  return _has_bit(3);
}
inline void l1_response::clear_found_vnode_succ() {
  if (found_vnode_succ_ != NULL) found_vnode_succ_->::dht::l1::vnodeid::Clear();
  _clear_bit(3);
}
inline const ::dht::l1::vnodeid& l1_response::found_vnode_succ() const {
  return found_vnode_succ_ != NULL ? *found_vnode_succ_ : *default_instance_->found_vnode_succ_;
}
inline ::dht::l1::vnodeid* l1_response::mutable_found_vnode_succ() {
  _set_bit(3);
  if (found_vnode_succ_ == NULL) found_vnode_succ_ = new ::dht::l1::vnodeid;
  return found_vnode_succ_;
}


}  // namespace l1
}  // namespace dht
#endif  // PROTOBUF_dht_5flayer1_2eproto__INCLUDED
